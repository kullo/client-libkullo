/* Copyright 2013â€“2015 Kullo GmbH. All rights reserved. */
#include "tests/api/apimodeltest.h"

#include <kulloclient/api/Address.h>
#include <kulloclient/api/Conversations.h>
#include <kulloclient/api/DateTime.h>
#include <kulloclient/api_impl/conversationsimpl.h>
#include <kulloclient/dao/conversationdao.h>
#include <kulloclient/event/conversationaddedevent.h>
#include <kulloclient/event/conversationremovedevent.h>

using namespace testing;
using namespace Kullo;

K_TEST(ApiConversationsStatic, emptyConversationTimestampIsInTheFuture)
{
    EXPECT_THAT(Api::DateTime::nowUtc(),
                Lt(Api::Conversations::emptyConversationTimestamp()));
}

class ApiConversations : public ApiModelTest
{
public:
    ApiConversations()
    {
        // emptyData.id is autogenerated by and read from DB
        emptyData.participant1 = "empty1#example.com";
        emptyData.participant2 = "empty2#example.com";
        auto emptyParticipants =
                emptyData.participant1 + "," + emptyData.participant2;

        // data.id is autogenerated by and read from DB
        data.participant1 = "1#example.com";
        data.participant2 = "2#example.com";
        auto participants = data.participant1 + "," + data.participant2;

        messageData.id = 0;
        messageData.dateSent = Api::DateTime(2015, 6, 23, 16, 06, 00, 120);

        dbSession_ = Db::makeSession(dbPath_);
        Db::migrate(dbSession_);

        Dao::ConversationDao emptyDao(dbSession_);
        emptyDao.setParticipants(emptyParticipants);
        emptyDao.save();
        emptyData.id = emptyDao.id();

        Dao::ConversationDao dao(dbSession_);
        dao.setParticipants(participants);
        dao.save();
        data.id = dao.id();

        Dao::MessageDao messageDao(dbSession_);
        messageDao.setConversationId(data.id);
        messageDao.setId(messageData.id);
        messageDao.setDateSent(messageData.dateSent->toString());
        messageDao.save(Dao::CreateOld::No);

        makeSession();
        uut = session_->conversations();
    }

protected:
    struct
    {
        int64_t id;
        std::string participant1;
        std::string participant2;
    } emptyData;

    struct
    {
        int64_t id;
        std::string participant1;
        std::string participant2;
    } data;

    struct
    {
        int64_t id;
        boost::optional<Api::DateTime> dateSent;
    } messageData;

    Db::SharedSessionPtr dbSession_;
    std::shared_ptr<Api::Conversations> uut;
};

K_TEST_F(ApiConversations, allWorks)
{
    auto conversations = uut->all();
    EXPECT_THAT(conversations, WhenSorted(ElementsAre(1, 2)));
}

K_TEST_F(ApiConversations, getWorks)
{
    std::unordered_set<std::shared_ptr<Api::Address>> participants;
    participants.emplace(Api::Address::create(data.participant1));
    participants.emplace(Api::Address::create(data.participant2));
    EXPECT_THAT(uut->get(participants), Eq(data.id));

    participants.emplace(Api::Address::create("nosuchuser#example.com"));
    EXPECT_THAT(uut->get(participants), Eq(-1));
}

K_TEST_F(ApiConversations, getWorksWithDuplicateAddresses)
{
    std::unordered_set<std::shared_ptr<Api::Address>> participants;
    participants.emplace(Api::Address::create(data.participant1));
    participants.emplace(Api::Address::create(data.participant1));
    participants.emplace(Api::Address::create(data.participant2));
    EXPECT_THAT(uut->get(participants), Eq(data.id));

    participants.emplace(Api::Address::create("nosuchuser#example.com"));
    EXPECT_THAT(uut->get(participants), Eq(-1));
}

K_TEST_F(ApiConversations, addReturnsExistingConversation)
{
    std::unordered_set<std::shared_ptr<Api::Address>> participants;
    participants.emplace(Api::Address::create(data.participant1));
    participants.emplace(Api::Address::create(data.participant2));

    EXPECT_THAT(uut->add(participants), Eq(data.id));
}

K_TEST_F(ApiConversations, addWorksWithDuplicateAddresses)
{
    std::unordered_set<std::shared_ptr<Api::Address>> participants;
    participants.emplace(Api::Address::create(data.participant1));
    participants.emplace(Api::Address::create(data.participant1));
    participants.emplace(Api::Address::create(data.participant2));
    auto convId = uut->add(participants);

    // must not create new conversation but return existing with {part1, part2}
    EXPECT_THAT(convId, Eq(data.id));
}

K_TEST_F(ApiConversations, addReturnsNewConversation)
{
    std::unordered_set<std::shared_ptr<Api::Address>> participants;
    participants.emplace(Api::Address::create(data.participant1));
    participants.emplace(Api::Address::create(data.participant2));
    participants.emplace(Api::Address::create("nosuchuser#example.com"));
    auto convId = uut->add(participants);

    EXPECT_THAT(convId, Ge(0));
    EXPECT_THAT(convId, Ne(data.id));
}

K_TEST_F(ApiConversations, addStoresToMemoryAndDatabase)
{
    std::unordered_set<std::shared_ptr<Api::Address>> participants;
    participants.emplace(Api::Address::create("local-new-guy1#example.com"));
    participants.emplace(Api::Address::create("local-new-guy2#example.com"));

    auto convId = uut->add(participants);

    // non-existing conversation defaults to empty participants set
    EXPECT_THAT(uut->participants(convId).size(), Eq(2u));

    // Existing in database
    {
        auto dao = Dao::ConversationDao::load(convId, dbSession_);
        ASSERT_THAT(dao, Not(IsNull()));
        EXPECT_THAT(dao->participantsList().size(), Eq(2u));
    }
}

K_TEST_F(ApiConversations, addEmitsEvent)
{
    std::unordered_set<std::shared_ptr<Api::Address>> participants;
    participants.emplace(Api::Address::create("local-new-guy1#example.com"));
    participants.emplace(Api::Address::create("local-new-guy2#example.com"));

    auto addedConvId = uut->add(participants);

    auto type = std::type_index(typeid(Event::ConversationAddedEvent));
    EXPECT_THAT(sessionListener_->internalEventCount(type), Eq(1));

    // send conversationAdded event
    auto uutImpl = std::dynamic_pointer_cast<ApiImpl::ConversationsImpl>(uut);
    ASSERT_THAT(uutImpl, Not(IsNull()));
    auto events = uutImpl->conversationAdded(addedConvId);

    // we'd like to get a notification that the conversation has been removed
    EXPECT_THAT(events, Contains(
                    Api::Event(Api::EventType::ConversationAdded, addedConvId, -1, -1))
                );

    // make sure that conversationAdded() updated the UUT
    EXPECT_THAT(uut->participants(addedConvId).size(), Eq(2u));
}

K_TEST_F(ApiConversations, removeWorks)
{
    // Existing in memory
    ASSERT_THAT(uut->participants(data.id).size(), Gt(0u));

    // Existing in database
    auto dao1 = Dao::ConversationDao::load(data.id, dbSession_);
    EXPECT_THAT(dao1, Not(IsNull()));

    uut->remove(data.id);

    // Deleted in memory
    EXPECT_THAT(uut->participants(data.id).size(), Eq(0u));

    // Deleted in database
    auto dao2 = Dao::ConversationDao::load(data.id, dbSession_);
    EXPECT_THAT(dao2, IsNull());
}

K_TEST_F(ApiConversations, removeEmitsEvents)
{
    uut->remove(data.id);

    // no worker event running
    auto type = std::type_index(typeid(Event::ConversationRemovedEvent));
    EXPECT_THAT(sessionListener_->internalEventCount(type), Eq(0));

    // we'd like to get a notification that the conversation has been removed
    auto events = sessionListener_->externalEvents();
    EXPECT_THAT(events, Contains(
                    Api::Event(Api::EventType::ConversationRemoved, data.id, -1, -1))
                );
}

K_TEST_F(ApiConversations, participantsWorks)
{
    auto participants = uut->participants(data.id);
    ASSERT_THAT(participants.size(), Eq(2u));
    bool found1 = false, found2 = false;
    for (auto &part : participants)
    {
        found1 = found1 || (part->toString() == data.participant1);
        found2 = found2 || (part->toString() == data.participant2);
    }
    EXPECT_THAT(found1, Eq(true));
    EXPECT_THAT(found2, Eq(true));

    EXPECT_THAT(uut->participants(42), IsEmpty());
}

K_TEST_F(ApiConversations, totalMessagesWorks)
{
    EXPECT_THAT(uut->totalMessages(emptyData.id), Eq(0));
    EXPECT_THAT(uut->totalMessages(data.id), Eq(1));

    EXPECT_THAT(uut->totalMessages(42), Eq(0));
}

K_TEST_F(ApiConversations, unreadMessagesWorks)
{
    EXPECT_THAT(uut->unreadMessages(emptyData.id), Eq(0));
    EXPECT_THAT(uut->unreadMessages(data.id), Eq(1));

    EXPECT_THAT(uut->unreadMessages(42), Eq(0));
}

K_TEST_F(ApiConversations, undoneMessagesWorks)
{
    EXPECT_THAT(uut->undoneMessages(emptyData.id), Eq(0));
    EXPECT_THAT(uut->undoneMessages(data.id), Eq(1));

    EXPECT_THAT(uut->undoneMessages(42), Eq(0));
}

K_TEST_F(ApiConversations, latestMessageTimestampWorks)
{
    EXPECT_THAT(uut->latestMessageTimestamp(emptyData.id),
                Eq(Api::Conversations::emptyConversationTimestamp()));

    EXPECT_THAT(uut->latestMessageTimestamp(data.id),
                Eq(messageData.dateSent));

    EXPECT_THAT(uut->latestMessageTimestamp(42),
                Not(Eq(messageData.dateSent)));
}

K_TEST_F(ApiConversations, idRangeWorks)
{
    for (auto convId : TEST_IDS_VALID)
    {
        EXPECT_NO_THROW(uut->participants(convId));
        EXPECT_NO_THROW(uut->totalMessages(convId));
        EXPECT_NO_THROW(uut->unreadMessages(convId));
        EXPECT_NO_THROW(uut->undoneMessages(convId));
        EXPECT_NO_THROW(uut->latestMessageTimestamp(convId));
        EXPECT_NO_THROW(uut->remove(convId));
    }

    for (auto convId : TEST_IDS_INVALID)
    {
        EXPECT_ANY_THROW(uut->participants(convId));
        EXPECT_ANY_THROW(uut->totalMessages(convId));
        EXPECT_ANY_THROW(uut->unreadMessages(convId));
        EXPECT_ANY_THROW(uut->undoneMessages(convId));
        EXPECT_ANY_THROW(uut->latestMessageTimestamp(convId));
        EXPECT_ANY_THROW(uut->remove(convId));
    }
}
